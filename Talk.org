#+TITLE: (Simile Free) Monad Recipes
#+AUTHOR: Aditya Siram
#+LaTeX_CLASS: beamer
#+LaTeX_CLASS_OPTIONS: [presentation]
#+BEAMER_HEADER_EXTRA: \usetheme{Madrid}\usecolortheme{default}
#+BEAMER_FRAME_LEVEL: 2
#+COLUMNS: %35ITEM %10BEAMER_env(Env) %10BEAMER_envargs(Env Args) %4BEAMER_col(Col) %8BEAMER_extra(Extra)
* IO
** Brief IO Example
*** This small function writes a text file, uppercases its contents & prints them..
#+BEGIN_SRC haskell
import Data.Char
main :: IO ()
main = do
    writeFile "test.txt" "a,b,c,d,e"
    x <- readFile "test.txt"
    let up_cased = map toUpper x
    y <- return up_cased
    print y
=> "A,B,C,D,E"
#+END_SRC
** Brief IO Example
*** With types added ...
#+BEGIN_SRC haskell
main :: IO ()
main = do
  writeFile "test.txt" "a,b,c,d,e" :: IO ()
  x :: String <- readFile "test.txt" :: IO String
  let upCased :: String = map toUpper x
  y :: String <- return upCased :: IO String
  print y :: IO ()
#+END_SRC
** Brief IO Example
*** Querying a Sqlite database
#+BEGIN_SRC haskell
get_users :: IO [(String,String)]
get_users = do
  rows :: [[SqlValue]] <
        dbQuery "select * from users" []
  let marshalled =
          map (\(user:pass:[]) ->
                   (fromSql user, fromSql pass))
              rows
  return marshalled
  where
    dbQuery sql values = ...
#+END_SRC
** Brief IO Example
*** The implementation of dbQuery isn't important, but here it is ...
#+BEGIN_SRC haskell
      dbQuery :: String -> [SqlValue] -> IO [[SqlValue]]
      dbQuery sql values =
            bracket dbConnect disconnect
              (\conn -> quickQuery' conn sql values)
      dbConnect :: IO Connection
      dbConnect = connectSqlite3 "test.sqlite"
#+END_SRC
* Reader
** Reader (1/2)
*** Reader = Read-only State + Result
*** 'runReader' :: Reader Monad -> Read-Only State -> Result
*** 'ask' extracts the state from the monad for inspection.
** Reader (2/2)
*** Authenticating users
#+BEGIN_SRC haskell
simple_auth :: (String,String) ->
               Reader [(String,String)] Bool
simple_auth (user,pass) = do
  users :: [(String,String)] <- ask
  case (lookup user users) of
    Nothing -> return False
    Just p -> return (p == pass)

main =
    let my_auth = ("deech","deechpassword") in
    do users :: [(String,String)] <- get_users
       print (runReader (simple_auth my_auth) users)
=> True
#+END_SRC
* Writer
** Writer
*** Writer = Append-Only State + Result
*** 'runWriter' :: Writer Monad -> (Result, Accumulated State)
*** State is accumulated using 'tell'
** Writer
*** Validating input
#+BEGIN_SRC haskell
validate :: String -> Writer [String] ()
validate input =
    let hasNumbers = (>= 2) . length . filter isDigit
        hasUppers  = (>= 1) . length . filter isUpper
        noSpaces   = null . filter (== ' ')
        check f input msg = if (not (f input))
                            then tell [msg]
                            else return ()
    in do check hasNumbers input "Needs 2+ numbers"
          check hasUppers  input "Needs 1+ capitals"
          check noSpaces   input "Has spaces"
#+END_SRC
** Writer
*** Running
#+BEGIN_SRC haskell
main = do
  let ((),errs) = runWriter (validate "abcde1")
      valid     = null errs
  if (not valid) then print errs else print "Valid!"
=> ["Needs 2+ numbers","Needs 1+ capitals"]
#+END_SRC
* State
** State
*** State Monad = Mutable State + Result
*** 'get', 'put' do what they sound like
*** 'runState' :: State Monad -> Initial State -> (Result, New State)
*** Initial State is *required*.
** State
*** Finding the minimum imperatively. Buggy!
#+BEGIN_SRC haskell
minimum_bad :: [Int] -> ((), Int)
minimum_bad [] = error "Empty List."
minimum_bad xs =
    runState (mapM_ compare xs :: State Int ()) (-1)
    where
      compare :: Int -> State Int ()
      compare curr = do
              old_min <- get
              if (curr < old_min)
              then put curr
              else return ()
minimum_bad [3,2,1] => ((),-1)
#+END_SRC
** State
*** `trace` and `printf` are your friends
#+BEGIN_SRC haskell
-- Debug.Trace.trace :: String -> a -> a
println msg = trace msg (return ())
#+END_SRC
** State
#+BEGIN_SRC haskell
minimum_bad xs = ...
      compare curr = do
              old_min <- get
              println (printf "old_min: %d curr: %d"
                               old_min curr)
              ...
minimum_bad [3,2,1] => ((), old_min: -1 curr: 3
                            old_min: -1 curr: 2
                            old_min: -1 curr: 1
                            -1)
#+END_SRC
** State
*** Fixed!
#+BEGIN_SRC haskell
-- minimum_bad xs =
--     runState (mapM_ compare xs) -1
minimum (x:xs) =
    runState (mapM_ compare xs) x
#+END_SRC

* Monad Transformers
** Transformers
*** Use all at once.
*** The Good: Combining monads is easy.
*** The Bad: Type sigs. and runners are more complicated.
*** The Sorta Good: It's pretty mechanical
** Transformers
*** An interactive version of auth
#+BEGIN_SRC haskell
interactive_auth = do
  let puts     msg = liftIO (putStrLn msg)
  let wait_for msg = do {puts msg; liftIO getLine}
  let log_failed   = do {puts "Invalid Login!";
                         tell ["Failed login attempt"]}
  let set_user u   = do {puts "Welcome!"; put u}
  users    <- ask
  user     <- wait_for "Username:"
  password <- wait_for "Password:"
  case (lookup user users) of
    Nothing -> log_failed
    Just p  -> if (p == password)
               then set_user user
               else log_failed
#+END_SRC
** Transformers
#+BEGIN_SRC haskell
interactive_auth :: ReaderT [(String,String)]
                            (WriterT [String]
                                     (StateT String
                                             IO))
                            ()
#+END_SRC
*** Transformer = Stack of Monads + Result
#+BEGIN_SRC haskell
interactive_auth = ... ()
#+END_SRC
** Transformers
#+BEGIN_SRC haskell
interactive_auth :: ReaderT [(String,String)]
                            (WriterT [String]
                                     (StateT String
                                             IO))
                            ()
#+END_SRC
*** Outer monad is ReaderT
#+BEGIN_SRC haskell
ReaderT [(String,String)] (WriterT ...) ()
#+END_SRC
*** Reader
#+BEGIN_SRC haskell
simple_auth :: Reader [(String,String)] Bool
#+END_SRC
*** Reader Transformer = ReaderT + Environment + M
#+BEGIN_SRC haskell
ReaderT [(String,String)] (WriterT ...) ()
#+END_SRC
** Transformers
#+BEGIN_SRC haskell
interactive_auth :: ReaderT [(String,String)]
                            (WriterT [String]
                                     (StateT String
                                             IO))
                            ()
#+END_SRC
*** 'runReader' :: Reader Monad -> Read-Only State -> Result
*** 'runReaderT' :: ReaderT Monad -> Read-Only State -> M Result
#+BEGIN_SRC haskell
let writer :: WriterT [String] (StateT Int IO) () =
   runReaderT interactive_auth users
#+END_SRC
** Transformers
#+BEGIN_SRC haskell
interactive_auth :: ReaderT [(String,String)]
                            (WriterT [String]
                                     (StateT String
                                             IO))
                            ()
#+END_SRC
*** Writer = Writer + Append-Only State + (Result, Accumulated State)
#+BEGIN_SRC haskell
validate :: String -> Writer [String] ()
#+END_SRC
*** WriterT Transformer = WriterT + Append-Only State + M
#+BEGIN_SRC haskell
WriterT [String] (... )
#+END_SRC
** Transformers
#+BEGIN_SRC haskell
interactive_auth :: ReaderT [(String,String)]
                            (WriterT [String]
                                     (StateT String
                                             IO))
                            ()
#+END_SRC
*** 'runWriter' :: Writer Monad -> (Result, Accumulated State)
*** 'runWriterT' :: WriterT Monad -> Append-Only State -> M (Result, Accumulated State)
#+BEGIN_SRC haskell
let writer = runReaderT interactive_auth users
let state :: (StateT String IO) ((), [String])
    = runWriterT writer
#+END_SRC
** Transformers
#+BEGIN_SRC haskell
interactive_auth :: ReaderT [(String,String)]
                            (WriterT [String]
                                     (StateT String
                                             IO))
                            ()
#+END_SRC
*** State = Mutable State + Result
#+BEGIN_SRC haskell
(mapM_ compare xs :: State Int ())
#+END_SRC
*** State Transformer = StateT + Mutable State + Underlying Monad
#+BEGIN_SRC haskell
StateT String IO (...)
#+END_SRC
** Transformers
#+BEGIN_SRC haskell
interactive_auth :: ReaderT [(String,String)]
                            (WriterT [String]
                                     (StateT String
                                             IO))
                            ()
#+END_SRC
*** 'runState' :: State Monad -> Initial State -> (Result, New State)
*** 'runStateT' :: StateT Monad -> Mutable State -> M (Result, New State)
#+BEGIN_SRC haskell
let writer = runReaderT interactive_auth users
let state  = runWriterT writer
let io :: IO (((), [String]), String) =
   runStateT state ""
#+END_SRC
** Running
*** Using `interactive\_auth`
#+BEGIN_SRC haskell
interactive_auth_driver = do
    let my_auth = ("deech","deechpassword")
    users <- get_users
    let writer = runReaderT interactive_auth users
    let state  = runWriterT writer
    let io     = runStateT  state ""
    final <- io
    print final
#+END_SRC
** Running    
*** Running with Control.Monad.RWS
#+BEGIN_SRC haskell
-- runRWST :: RWST Monad ->
              Read-Only State ->
              Mutable State ->
              Lowest Monad
interactive_auth_driver' = do
    let my_auth = ("deech","deechpassword")
    users <- get_users
    final <- runRWST interactive_auth users ""
    print final
#+END_SRC
** Running
*** Sample session 1
#+BEGIN_SRC haskell
Username:
deech
Password:
wrongpassword
(((),["Failed login attempt"]),"")
#+END_SRC
*** Sample session 2
#+BEGIN_SRC haskell
Username:
deech
Password:
deechpassword
Welcome!
(((),[]),"deech")
#+END_SRC
